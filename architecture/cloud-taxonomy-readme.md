# Cloud Taxonomy

### Cloud hosting/service models
IaaS, PaaS, SaaS

### Cloud deployment models
Public, Private, Hybrid, Multi-Cloud

### Cloud adoption (migration) strategies
* Determine goals & objectives
    * cost
    * agility - how quickly IT can respond to business
    * developer experience
    * cloud as a capability

After the landscape has been identified, layout the plan
* Re-hosting - lift & shift, migration - more associated with cost (based on personal experience)
* Refactor - Cloud optimized - PaaS services like Azure WebApp (Enterprises who are at *Intermediate* stage in terms of cloud adoption)
* Re-architect - Cloud native - Micro-services AKS, Branch Office (Enterprises who are at *Advanced* stage in terms of cloud adoption)
* Replace - the existing solution with a SaaS solution

Categorize strategies across Application & Data
* Application strategy - legacy apps may fall under re-hosting or cloud optimized, greenfield apps under cloud native
* Data strategy - Storing data based on classification, as per GDPR regulation, Encryption (customer managed vs cloud vendor managed)

Once the goals have been identified, how they can be achieved
* Technology
    * Kind of hosting model - IaaS, PaaS, SaaS
    * Deployment models - Public, Private, Hybrid, Multi-Cloud
* Process
    * Solution delivery process, CI/CD pipelines, automation
* People
    * Training, boot camps, tech-talks

### Cloud maturity models
Cloud optimized - develop your app in an agile manner from other on-premises apps, & then release, deploy, auto-scale, monitor & troubleshoot your app in the cloud. Eg: PaaS services like WebApp

![Alt text](/images/cloud-optimized.jpg)

Cloud native - Theyâ€™re based on microservices architectures, use managed services, and take advantage of continuous delivery to achieve reliability and faster time to market. Eg: AKS.

They are based on 12 Factor applications (introduced in 2011, and now going [Beyond the 12-Factor app](https://content.pivotal.io/blog/beyond-the-twelve-factor-app))

| S.N. |	Factor  | 	Explanation |
| :-:|:- | :- |
|   1   |	Code Base   |	A single code base for each microservice, stored in its own repository. Tracked with version control, it can deploy to multiple environments (QA, Staging, Production). |
| 2	| Dependencies |	Each microservice isolates and packages its own dependencies, embracing changes without impacting the entire system. |
| 3 |	Configurations	| Configuration information is moved out of the microservice and externalized through a configuration management tool outside of the code. The same deployment can propagate across environments with the correct configuration applied. |
| 4 |	Backing Services |	Ancillary resources (data stores, caches, message brokers) should be exposed via an addressable URL. Doing so decouples the resource from the application, enabling it to be interchangeable. |
| 5 |	Build, Release, Run |	Each release must enforce a strict separation across the build, release, and run stages. Each should be tagged with a unique ID and support the ability to roll back. Modern CI/CD systems help fulfill this principle. |
| 6 |	Processes |	Each microservice should execute in its own process, isolated from other running services. Externalize required state to a backing service such as a distributed cache or data store. |
| 7 |	Port Binding |	Each microservice should be self-contained with its interfaces and functionality exposed on its own port. Doing so provides isolation from other microservices. |
| 8 |	Concurrency	| Services scale out across a large number of small identical processes (copies) as opposed to scaling-up a single large instance on the most powerful machine available. |
| 9 |	Disposability |	Service instances should be disposable, favoring fast startups to increase scalability opportunities and graceful shutdowns to leave the system in a correct state. Docker containers along with an orchestrator inherently satisfy this requirement. |
| 10 |	Dev/Prod Parity |	Keep environments across the application lifecycle as similar as possible, avoiding costly shortcuts. Here, the adoption of containers can greatly contribute by promoting the same execution environment. |
| 11 |	Logging |	Treat logs generated by microservices as event streams. Process them with an event aggregator and propagate the data to data-mining/log management tools like Azure Monitor or Splunk and eventually long-term archival. |
| 12 |	Admin Processes	| Run administrative/management tasks as one-off processes. Tasks can include data cleanup and pulling analytics for a report. Tools executing these tasks should be invoked from the production environment, but separately from the application. |

### Beyond 12-factor
| S.N. |	Factor  | 	Explanation |
| :-:|:- | :- |
| 13 |	API First | Make everything a service. Assume your code will be consumed by a front-end client, gateway, or another service. |
| 14 | Telemetry | On a workstation, you have deep visibility into your application and its behavior. In the cloud, you don't. Make sure your design includes the collection of monitoring, domain-specific, and health/system data. |
| 15 | Authentication/ Authorization | Implement identity from the start. Consider RBAC (role-based access control) features available in public clouds. |
